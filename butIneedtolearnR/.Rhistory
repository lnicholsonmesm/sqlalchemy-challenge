install.packages('RPostgreSQL')
# Dependencies
# ******************************************************************************
library(tidyverse)
library(dbplyr)
library(RPostgreSQL)
dbConnect?
?dbConnect
connection <- dbConnect(RSQLite::SQLite(),":memory")
if(!'SQLite' %in% installed.packages()){
install.packages('SQLite')
}
install.packages("RSQLite")
install.packages("RSQLite")
connection <- dbConnect(RSQLite::SQLite(),":memory")
# Dependencies
# ******************************************************************************
library(tidyverse)
#library(dbplyr) #dbplyr is in the tidyverse
#library(RPostgreSQL) #not using PostgreSQL
if(!'RSQLite' %in% installed.packages()){
install.packages('RSQLite')
}
connection <- dbConnect(RSQLite::SQLite(),":memory")
?dbConnect
?dbplyr
# Dependencies
# ******************************************************************************
library(tidyverse)
library(dbplyr)
connection <- dbConnect(RSQLite::SQLite(),":memory")
install.packages('RSQLite')
install.packages('RSQLite')
install.packages('RSQLite')
install.packages("RSQLite")
library(c(tidyverse, dbplyr, RSQLite))
library(tidyverse)
library(dbplyr)
library(RSQLite)
connection <- dbConnect(RSQLite::SQLite(),":memory")
connection
# if I needed to connect with a password, I'd use a config file (maybe) and access it with source(config.R) Then I would do something like:
#driver <- dbDriver("PostgreSQL")
#connection <- dbConnect(driver, host=host, user=user, password=password, dbname=dbname, port=port)
## SQLite only needs a path to the database. (Here, ":memory:" is a special
# if we're creating data, we can use path=":memory:" to create an in-memory database.) Other database drivers
# will require more details (like user, password, host, port, etc.)
con <- dbConnect(RSQLite::SQLite(), path = "./Resources/Hawaii.sqlite")
con
library(tidyverse)
library(dbplyr)
library(RSQLite)
con <- dbConnect(RSQLite::SQLite(), path = "./Resources/Hawaii.sqlite")
con
remote_src()
remote_src(con)
#' Get the table information for a postgres database
#' @param config the configuration list
#' @return the table names, columns, and column types of all columns in the database
getTableInformation <- function(config = config.gp) {
tables <- fetchQuery(
"SELECT table_name, column_name, data_type
FROM information_schema.columns
WHERE table_name NOT LIKE '%prt%'
AND table_name NOT LIKE '%ext%'
AND table_name NOT LIKE '%tmp%'
ORDER BY 1, 2",
config
)
}
#' Replacement of the normal update function, you don't need to call this.
args <- list(...)
#' Function to reflect a database, generalizable to others beyond postgres
#' by simply changing getTableInformation appropriately
reflectDatabase <- function(config, envir.name = "tables",
subclass = "postgres") {
if (!(envir.name %in% search())) {
envir <- new.env(parent = .GlobalEnv)
} else {
envir <- as.environment(envir.name)
detach(envir.name, character.only = TRUE)
}
src <- do.call(src_postgres, config)
tables <- getTableInformation(config)
tables <- split(tables, tables$table_name)
lapply(tables, function(i) {
nm <- ident(i$table_name[1])
vars <- lapply(i$column_name, as.name)
tbl <- dplyr::make_tbl(c(subclass, "sql"), src = src, from = nm,
select = vars, summarise = FALSE, mutate = FALSE,
where = NULL, group_by = NULL, order_by = NULL)
tbl <- update(tbl)
assign(
nm,
tbl,
envir = envir
)
})
attach(envir, name = envir.name)
}
searchTables <- function(str, env = "tables") {
all.tbls <- ls(env)
all.tbls[grep(str, all.tbls)]
}
reflectDatabase()
reflectDatabase(con)
envir <- new.env(parent = .GlobalEnv)
reflectDatabase(con)
tables <- getTableInformation(config)
reflectDatabase(con)
reflectDatabase(con, env="tables")
remote_name(con)
?remote_name
con <- dbConnect(RSQLite::SQLite(), path = "./Resources/hawaii.sqlite")
con
remote_name(con)
remote_src(con)
dbSendQuery(con, table_names)
dbSendQuery(con, table_name)
dbSendQuery(con)
tbl(con, "hawaii_measurements")
tbl(con, "measurements")
remote_query_plan(con)
dbManager(con)
library(RSQLite)
m <- dbManager(dbms)
db_desc(con)
getTableInformation(con, "hawaii")
getTableInformation(con)
table_name_query = "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
getTableInformation(con)
tables <- dbSendQuery(
"SELECT table_name, column_name, data_type
FROM information_schema.columns
WHERE table_name NOT LIKE '%prt%'
AND table_name NOT LIKE '%ext%'
AND table_name NOT LIKE '%tmp%'
ORDER BY 1, 2",
config
)
tables <- dbSendQuery(con,
"SELECT table_name, column_name, data_type
FROM information_schema.columns
WHERE table_name NOT LIKE '%prt%'
AND table_name NOT LIKE '%ext%'
AND table_name NOT LIKE '%tmp%'
ORDER BY 1, 2"#,
#config
)
dbSendQuery(con, table_name_query)
data <- dbSendQuery(con, "SELECT * FROM hawaii")
dbDisconnect()
dbDisconnect(con)
data <- dbSendQuery(con, "SELECT * FROM measurements")
##dbConnect()
con <- dbConnect(RSQLite::SQLite(), path = "./Resources/hawaii.sqlite")
con
# ******************************************************************************
db_desc(con) #this told me it was sqlite 3.30.1
data <- dbSendQuery(con, "SELECT * FROM measurements")
data <- dbSendQuery(con, "SELECT * FROM hawaii")
data <- dbSendQuery(con, "SELECT * FROM Measurements")
table_name_query = "SELECT name FROM hawaii WHERE type='table' ORDER BY name"
dbSendQuery(con, table_name_query)
## TRYING TO INSPECT DATABASE:
dbSendQuery(con, ".tables")
dbSendQuery(con, "SELECT name from sqlite_master WHERE type =  'table' AND name NOT LIKE 'sqlinte_%';")
## TRYING TO INSPECT DATABASE:
tablenames_maybe <- dbSendQuery(con, "SELECT name from sqlite_master WHERE type =  'table' AND name NOT LIKE 'sqlinte_%';")
dbDisconnect(con)
##dbConnect()
con <- dbConnect(RSQLite::SQLite(), path = "./Resources/hawaii.sqlite")
con
## Query All Records in the the Database
#data = engine.execute("SELECT * FROM Census_Data")
dbSendQuery(con, "SELECT * FROM sqlite_master")
dbGetQuery(con, SELECT * FROM sqlite_master)
dbGetQuery(con, "SELECT * FROM sqlite_master")
dbDisconnect(con)
##dbConnect()
con <- dbConnect(RSQLite::SQLite(), path = "./Resources/hawaii.sqlite")
dbGetQuery(con, "SELECT * FROM sqlite_master")
getwd()
path2 = "/Users/lauranicholson/Desktop/data_analysis/bootcamp/Homework/sqlalchemy-challenge/butIneedtolearnR/Resources/hawaii.sqlite"
con <- dbConnect(RSQLite::SQLite(), path2)
con
dbGetQuery(con, "SELECT * FROM sqlite_master")
## TRYING TO INSPECT DATABASE:
tablenames_maybe <- dbSendQuery(con, "SELECT name from sqlite_master WHERE type =  'table' AND name NOT LIKE 'sqlinte_%';")
tablenames_maybe
con
# ******************************************************************************
db_desc(con) #this told me it was sqlite 3.30.1
table_name_query = "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
dbSendQuery(con, table_name_query)
## Query All Records in the the Database
#data = engine.execute("SELECT * FROM Census_Data")
dbSendQuery(con, "SELECT * FROM sqlite_master")
dbDisconnect(con)
con <- dbConnect(RSQLite::SQLite(), path2)
# ******************************************************************************
db_desc(con) #this told me it was sqlite 3.30.1
## TRYING TO INSPECT DATABASE:
tablenames_maybe <- dbSendQuery(con, "SELECT name from sqlite_master WHERE type =  'table' AND name NOT LIKE 'sqlite_%';")
tablenames_maybe
dbDisconnect(con)
library(tidyverse)
library(dbplyr)
library(RSQLite)
path2 = "/Users/lauranicholson/Desktop/data_analysis/bootcamp/Homework/sqlalchemy-challenge/butIneedtolearnR/Resources/hawaii.sqlite"
con <- dbConnect(RSQLite::SQLite(), path2)
data <- dbSendQuery(con, "SELECT * FROM measurements")
data <- dbSendQuery(con, "SELECT * FROM Measurements")
data <- dbSendQuery(con, "SELECT * FROM hawaii")
data <- dbSendQuery(con, "SELECT * FROM hawaii")
data <- dbSendQuery(con, "SELECT * FROM Hawaii")
## Query All Records in the the Database
#data = engine.execute("SELECT * FROM Census_Data")
dbSendQuery(con, "SELECT * FROM sqlite_master")
con
# ******************************************************************************
db_desc(con) #this told me it was sqlite 3.30.1 aaand showed me the path
dbGetQuery(con, "SELECT * FROM sqlite_master")
## TRYING TO INSPECT DATABASE:
tablenames_maybe <- dbGetQuery(con, "SELECT name from sqlite_master WHERE type =  'table' AND name NOT LIKE 'sqlite_%';")
tablenames_maybe
table_name_query = "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
tablenames_maybe <- dbGetQuery(con, table_name_query)
tablenames_maybe
library(tidyverse)
library(dbplyr)
library(RSQLite)
path2 = "/Users/lauranicholson/Desktop/data_analysis/bootcamp/Homework/sqlalchemy-challenge/butIneedtolearnR/Resources/hawaii.sqlite"
con <- dbConnect(RSQLite::SQLite(), path2)
con
# GET TABLE NAMES/INSPECT DB
db_desc(con) #this told me it was sqlite 3.30.1 aaand showed me the path
dbGetQuery(con, "SELECT * FROM sqlite_master") #note: dbSendQuery doesn't work like I thought it would. need to use "GetQuery"
table_name_query = "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
tbl_name_query2 = "SELECT name from sqlite_master WHERE type =  'table' AND name NOT LIKE 'sqlite_%';"
tablenames_maybe <- dbGetQuery(con, table_name_query)
tablenames_maybe
Station <- dbGetQuery(con, "SELECT * FROM station")
## TRYING TO INSPECT DATABASE:
Station
Measurement <- dbGetQuery(con, "SELECT * FROM measurement")
metadata <- dbGetQuery(con, "SELECT * FROM sqlite_master") #note: dbSendQuery doesn't work like I thought it would. need to use "GetQuery"
metadata
dbGetQuery(SELECT tdate FROM station)
dbGetQuery(con, "SELECT tdate FROM station")
dbGetQuery(con, "SELECT date FROM station")
dbGetQuery(con, "SELECT names FROM station")
remote_name("station")
remote_name(station)
remote_name(Station)
dbGetQuery(con, "SELECT dates FROM station")
dbGetQuery(con, "SELECT * FROM station")
dbGetQuery(con, "SELECT * FROM measurement")
dbGetQuery(con, "SELECT max(date) FROM measurement")
remote_name(Station)
con %>% tbl("station")
# Explore the data
# ******************************************************************************
dbGetQuery(con, "SELECT max(date) FROM measurement")
dbGetQuery(con, "SELECT min(date) FROM measurement")
#max date is 2017-08-23, so the last 12 months of precipitation data will go back to 2016-08-23ish
names(Station_v1)
Station_v1 <- dbGetQuery(con, "SELECT * FROM station")
#max date is 2017-08-23, so the last 12 months of precipitation data will go back to 2016-08-23ish
names(Station_v1)
#max date is 2017-08-23, so the last 12 months of precipitation data will go back to 2016-08-23ish
Station_v1_columns <- names(Station_v1)
Measurement_v1_columns <- names(Measurement_v1)
Measurement_v1 <- dbGetQuery(con, "SELECT * FROM measurement")
Station_v2 <- con %>% tbl("station")
Measurement_v2 <- con %>% tbl(" measurement")
Measurement_v2 <- con %>% tbl("measurement")
Station_v1_columns
Measurement_v1_columns
Measurement_v1_columns <- names(Measurement_v1)
Station_v1_columns
Measurement_v1_columns
library(tidyverse)
library(dbplyr)
library(RSQLite)
##dbConnect()
path1 = "./Resources/hawaii.sqlite"
path2 = "/Users/lauranicholson/Desktop/data_analysis/bootcamp/Homework/sqlalchemy-challenge/butIneedtolearnR/Resources/hawaii.sqlite"
con <- dbConnect(RSQLite::SQLite(), path2)
con
# GET TABLE NAMES/INSPECT DB
db_desc(con) #this told me it was sqlite 3.30.1 aaand showed me the path
metadata <- dbGetQuery(con, "SELECT * FROM sqlite_master") #note: dbSendQuery doesn't work like I thought it would. need to use "GetQuery"
table_name_query = "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
tbl_name_query2 = "SELECT name from sqlite_master WHERE type =  'table' AND name NOT LIKE 'sqlite_%';"
tablenames_maybe <- dbGetQuery(con, table_name_query)
tablenames_maybe
Station_v1 <- dbGetQuery(con, "SELECT * FROM station")
Measurement_v1 <- dbGetQuery(con, "SELECT * FROM measurement")
Station_v2 <- con %>% tbl("station")
Measurement_v2 <- con %>% tbl("measurement")
# Explore the data
# ******************************************************************************
dbGetQuery(con, "SELECT max(date) FROM measurement")
dbGetQuery(con, "SELECT min(date) FROM measurement")
#max date is 2017-08-23, so the last 12 months of precipitation data will go back to 2016-08-23ish
Station_v1_columns <- names(Station_v1)
Measurement_v1_columns <- names(Measurement_v1)
# Explore the data
# ******************************************************************************
class(dbGetQuery(con, "SELECT max(date) FROM measurement"))
# Explore the data
# ******************************************************************************
maxdate <- dbGetQuery(con, "SELECT max(date) FROM measurement")
maxdate
class(maxdate) #data.frame makes dealing with this easy, I think.
type(maxdate)
#max date is 2017-08-23, so the last 12 months of precipitation data will go back to 2016-08-23ish
Station_v1_columns <- names(Station_v1)
Measurement_v1_columns <- names(Measurement_v1)
Station_v1_columns
Measurement_v1_columns
#Get last year of data, retrieving date and precipitation (date, prcp) values only
precipitation <- con%>%tbl(sql("SELECT date, prcp FROM station WHERE date >= '2016-08-23'"))
#Get last year of data, retrieving date and precipitation (date, prcp) values only
precipitation <- con%>%tbl(sql("SELECT date, prcp FROM measurement WHERE date >= '2016-08-23'"))
precipitation
#date is a character column--going to make it a date with lubridate package
library(lubridate)
?`lubridate-package`
precipitation %>% select(date = ymd(date))
precipitation$date <- ymd(precipitation$date)
precipitation
class(precipitation$date)
#pull into pandas df and set index to date
precipitation
#pull into pandas df and set index to date
precip_tibble <- tibble(precipitation)
#pull into pandas df and set index to date. My first idea was that it was more or less already saved in a tibble, but maybe it wasn't a real one, so I could stick it there. That didn't work, since it's a "tbl_SQLiteConnection" instead of a 1d or 2d object.
#ah yes, collect() was the function
precip_tibble <- collect(precipitation)
precip_tibble
?tibble
glimpse(precip_tibble) # this will be super useful for my 400-column table later
precip_tibble %>% ggplot() +
geom_bar(mapping = aex(x = date))
precip_tibble %>% ggplot() +
geom_bar(mapping = aes(x = date))
precip_tibble %>% ggplot() +
geom_bar(mapping = aes(x = date))
precip_tibble %>% ggplot() +
autoplot(precip_tibble)
precip_df <- tibble(precip_tibble)
precip_tibble %>% ggplot() +
autoplot(precip_df)
glimpse(precip_tibble) # this will be super useful for my 400-column table later
#barplot of precipitation stuff
# ******************************************************************************
x = precip_df %>% select(date)
#barplot of precipitation stuff
# ******************************************************************************
x = precip_df %>% select("date")
names(precip_df)
precip_df
precip_tibble
#barplot of precipitation stuff
# ******************************************************************************
x = precip_tibble %>% select("date")
y = precip_df %>% select(prcp)
y = precip_tibble %>% select(prcp)
## MAKING IT AS A TIME SERIES
ts (precip_tibble, start=c(2016), end=c(2017), frequency=1) # Yearly Data
autoplot(precip_tibble)
summarize(precip_tibble)
prcp_graph <- ggplot(precip_tibble,
aes(x=`date`, y=prcp)) +
geom_bar(stat = 'identity', width = 0.2)
prcp_graph
prcp_graph <- ggplot(precip_tibble,
aes(x=`date`, y=prcp)) +
geom_bar(stat = 'identity', width = 0.2) +
xlab("Date") +
ylab("Precipitation (in)")
prcp_graph
prcp_graph <- ggplot(precip_tibble,
aes(x=`date`, y=prcp)) +
geom_bar(stat = 'identity', width = 0.2) +
xlab("Date") +
ylab("Precipitation (in)") +
title("Measured Rainfall, August 2016 - August 2017")
prcp_graph
## MAKING IT AS A TIME SERIES
ts (precip_tibble, start=c(2016), end=c(2017), frequency=1) # Yearly Data
## MAKING IT AS A TIME SERIES
precip_nonas <- precip_tibble %>% filter(!is.na(`date`, !is.na(prcp)))
## MAKING IT AS A TIME SERIES
precip_nonas <- precip_tibble %>% filter(!is.na(`date`), !is.na(prcp))
ts (precip_nonas, start=c(2016), end=c(2017), frequency=1) # Yearly Data
ts (precip_nonas, start=c(2016-08-23), end=c(2017-08-23), frequency=1) # Yearly Data
ts (precip_nonas, start=c('2016-08-23'), end=c('2017-08-23'), frequency=1) # Yearly Data
install.packages("devtools")
install.packages("devtools")
devtools::install_deps()
library(devtools)
devtools::install_deps()
install.packages("devtools")
